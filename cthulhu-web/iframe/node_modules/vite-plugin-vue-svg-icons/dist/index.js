import { join as N, resolve as M } from "path";
import b from "node:fs";
const k = {
  // green: (text: string) => `\x1B[32m${text}\x1B[0m`,
  yellow: (e) => `\x1B[33m${e}\x1B[0m`
  // red: (text: string) => `\x1B[31m${text}\x1B[0m`,
  // BgRed: (text: string)=> `\x1b[41m${text}`,
};
function P(e) {
  let n = [], t = 0, i = 0;
  for (; t = e.indexOf("http", i), !(t === -1 || (i = e.indexOf('"', t), i === -1)); ) {
    const c = e.slice(t, i);
    n.push(c);
  }
  return n;
}
const q = [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkgrey",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkslategrey",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dimgrey",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "green",
  "greenyellow",
  "grey",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightgrey",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightslategrey",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "slategrey",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
];
function B() {
  return new RegExp(`(#(?:[0-9a-fA-F]{3}){1,2}|rgba?\\(\\d+,\\s*\\d+,\\s*\\d+(?:,\\s*[\\d.]+)?\\)|(?:hsla?|hsl)\\(\\d+(?:,\\s*\\d+%)\\{2\\}(?:,\\s*[\\d.]+)?\\)|\\b(?:${q.join("|")})\\b|hsla?\\([^)]*\\))`, "g");
}
function F(e) {
  const n = B(), t = /(?:color|fill|stroke)="([^"]+)"/g;
  let i, c = [];
  for (; (i = t.exec(e)) !== null; )
    c.push(i[0]);
  const o = e.match(n);
  if (!o || o.length === 1)
    return { bool: !1, colors: o };
  const m = o[0];
  let p = 1;
  for (let g = 1; g < o.length; g++)
    o[g] === m && p++;
  return p === o.length ? { bool: !1, colors: o, colorAttrNames: c } : { bool: !0, colors: o, colorAttrNames: c };
}
function H(e) {
  const n = /<path/g, t = e.match(n);
  return t ? t.length : 0;
}
function R(e) {
  return "<style>#" + e + " {position: absolute; left: -100%;bottom: -100%; width: 0; height: 0;}</style>";
}
function T(e, n, t) {
  return `<symbol id="${e}-${n}">${t}</symbol>`;
}
function A(e, n) {
  return `<svg id="${e}" xmlns="http://www.w3.org/2000/svg" xmlns:link="http://www.w3.org/1999/xlink"><defs>${n}</defs></svg>`;
}
function C(e, n) {
  const t = /\[--iconPrefix--\]/g;
  return e.replace(t, `${n}`);
}
function V(e) {
  const t = /data:(image|audio|video)\/[^;]+;base64,([^"]+)/g.exec(e);
  for (; t !== null; )
    if (t[1])
      return !0;
  return !1;
}
function j(e) {
  const n = [], t = [];
  for (let i = 0; i < e.length; i++) {
    const c = e[i], o = i;
    !n.includes(c) && !t.includes(o) && (n.push(c), t.push(o));
  }
  return n;
}
function L(e, n) {
  var a, u, f;
  if (n = Object.assign({
    protect: !0,
    clearOriginFill: !0
  }, n), !e)
    return;
  const i = P(e).find((h) => h && h.indexOf("//www.w3.org") <= 0);
  if (n.protect && (e.indexOf("function") >= 0 || e.indexOf("Function()") >= 0 || e.indexOf("[native code]") >= 0 || e.indexOf("<script") >= 0 || e.indexOf("<foreignObject") >= 0 || i) && (n.isWarn && console.warn(k.yellow("➜ " + n.name + ".svg There is a risk of XSS attacks in your SVG! The plug-in is blocked, at this time your svg cannot be displayed, forcibly open")), n.isWarn && console.warn(k.yellow("➜ SVG图标中可能存XSS 攻击的风险！"))), V(e))
    return n.isWarn && console.warn(k.yellow("➜ " + n.name + ".svg 这是一个包含base64格式的数据图标！ 不建议把它当作svg使用!")), `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 80 20">
        <text x="40" y="15" font-size="12" fill="#f00000" text-anchor="middle">Not supported</text>
      </svg>`;
  const c = /<svg([^>]+)/g;
  if (!e.match(c))
    return null;
  let o = e.match(c)[0];
  const m = /\s+width=".+?"/s, p = /\s+height=".+?"/s, g = /\s+class=".+?"/g, $ = /\s+fill="url\(#(\w+)\)"/g, l = /\s+stroke="([^"]+)"/g;
  o.match(m) && (e = e.replace(m, " ")), o.match(p) && (e = e.replace(p, " ")), o.match(g) && (e = e.replace(g, " "));
  const r = F(e), d = `--${n.name}-svg-color`;
  if (r.bool) {
    if (e = e.replace(/<svg/g, '<svg multicolor="true" '), n.isMultiColor) {
      const h = j(r.colors);
      e = e.replace(/<svg/g, `<svg color-length="${h.length}" `);
      let y = "<style>:root {";
      for (let w = 0; w < h.length; w++) {
        const I = h[w], v = (a = r.colorAttrNames) == null ? void 0 : a.find((x) => x.indexOf(I) >= 0), O = d + "-" + w;
        if (v && v !== 'fill="none"') {
          const x = v.split("=")[0], E = new RegExp(`${v}`, "g");
          e = e.replace(E, `${x}="var(${O})" `);
        }
        y += `${O}: ${I};`;
      }
      y += "}</style>", e = e.replace(/<svg/g, `${y} <svg`);
    }
  } else
    $.test(e) || (e = e.replace(/<svg/g, '<svg multicolor="false"'), (H(e) === ((u = r.colors) == null ? void 0 : u.length) || H(e) === 1) && n.clearOriginFill ? e = e.replace(/fill="([^"]+)"/g, "") : l.test(e) && (e = e.replace(l, ` stroke="var(${d})"`), (f = r.colors) != null && f.length && (e = e.replace(/<svg/g, `<style>:root{ ${d}: ${r.colors[0]} }</style> <svg`))));
  return e;
}
function W(e, n) {
  return `
        if (typeof window !== 'undefined') {
            function loadSvgIcons() {
                var body = document.body;
                var svgEl = document.createElement('svg');
                svgEl.style.position = 'absolute';
                svgEl.style.top = '-100%';
                svgEl.style.left = '-100%';
                svgEl.innerHTML = "${n}";
                body.insertBefore(svgEl, body.lastChild);
            }
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', loadSvgIcons);
            } else {
                loadSvgIcons()
            }
        }
    `;
}
function G(e) {
  return e.replace(/\s+/g, " ").replace(/<!--[\s\S]*?-->/g, "").replace(/>\s+</g, "><");
}
function U(e) {
  return e.replace(/"/g, '\\"');
}
const _ = `import { h } from 'vue';
export default {
    render() {
        let domAttr = {
            innerHTML: \`<use href="#[--iconPrefix--]-\${this.name}" />\`
        }
        let width = this.size;
        let height = this.size;
        if (typeof this.size == 'object') {
            width = this.size[0];
            height = this.size[1] || this.size[0];
        }
        if (this.size) {
            domAttr.width = this.size;
            domAttr.height = this.size;
        }
        if (width) {
            domAttr.width = width;
        }
        if (height) {
            domAttr.height = height;
        }
        if (this.class) {
            domAttr.class = [this.class];
        }
        domAttr.fill = this.color || '#718190';
        domAttr['aria-hidden'] = true;
        return h(
            'svg',
            {
                ...domAttr
            },
        )
    },
    props: {
        name:{ 
            type: String, 
            default: '',
        },
        size: {
            type: [Array, String, Number], 
            default: 0
        },
        color: { 
            type: String, 
            default: '' 
        },
        class: { 
            type: String, 
            default: '' 
        }
    }
}`, z = "vite-plugin-vue-svg-icons";
let s = {
  moduleId: "virtual:svg-icon",
  ssr: !1,
  dir: N(`${process.cwd()}/src/assets/svg`),
  svgId: "__v__svg__icons",
  iconPrefix: "icona",
  clearOriginFill: !0,
  isNameVars: !1,
  isWarn: !0,
  isMultiColor: !0
};
function J(e) {
  let n = [], t = "";
  s = Object.assign(s, e);
  const i = s.moduleId, c = "\0" + i, o = async (l, r = []) => {
    let d = b.readdirSync(l);
    return d.length === 0 ? (console.warn(z + ":File directory is empty --->" + s.dir), []) : (d.forEach((a) => {
      if (b.lstatSync(`${l}/${a}`).isDirectory())
        o(`${l}/${a}`, r);
      else {
        if (a.lastIndexOf(".svg") === -1)
          return;
        r.push({
          path: `${l}/${a}`,
          filename: a
        });
      }
    }), r);
  };
  async function m(l) {
    const r = l;
    if (!b.existsSync(r))
      return console.warn(`\x1B[31m${z}:The directory does not exist ---->${r}\x1B[0m`), null;
    const d = await o(r);
    return n = [], t = "", d.forEach((a) => {
      let u = b.readFileSync(a.path, "utf8");
      const f = a.filename.replace(/.svg/g, "");
      n.push(f);
      const h = L(u, {
        name: f,
        clearOriginFill: s.clearOriginFill,
        isWarn: !!s.isWarn,
        isMultiColor: !!s.isMultiColor
      });
      let y = T(s == null ? void 0 : s.iconPrefix, f, h);
      t += y;
    }), t;
  }
  function p(l) {
    if (!s.ssr)
      return l;
    const r = R(s.svgId), d = A(s.svgId, t);
    return `${l}${d} ${r}`;
  }
  let g = "";
  return {
    // name: 'vite:svg-map-icons',
    name: "virtual:svg-icon",
    // apply: 'serve',
    configResolved(l) {
      g = M(l.root, `${s.dir}`), m(g);
    },
    transformIndexHtml: p,
    resolveId(l) {
      if (l === i)
        return c;
    },
    async load(l) {
      if (l === c) {
        const r = `${s.isNameVars ? "export const svgIconNames =" + JSON.stringify(n) : ""}`;
        if (s.ssr)
          return `${C(_, s.iconPrefix)};
                    
// svg目录的svg名称集合的数组, 新加、删除svg文件时该变量还不支持热更
                    
 ${r}
                    `;
        const d = U(G(A(s.svgId, t)));
        return `
                    ${C(_, s.iconPrefix)};

                    ${W(s.svgId, d)}

                    ${r};
                `;
      }
    },
    // transform(code, id) {
    //     if (id === resolvedModuleId) {
    //         console.log('===', id);
    //     }
    // },
    async handleHotUpdate(l) {
      const r = M(l.server.config.root, `${s.dir}`);
      async function d(a) {
        if (l.file.indexOf(a) >= 0 || l.file.indexOf(".svg") >= 0) {
          await m(r);
          try {
            const { moduleGraph: u } = l.server, f = u.getModuleById(c);
            return l.server.ws.send({
              type: "full-reload",
              path: "*"
            }), f ? [...f] : !0;
          } catch {
          }
        }
        return !0;
      }
      return l.server.watcher.on("unlink", async (a) => {
        await d(a);
      }), await d(r);
    }
  };
}
export {
  J as default
};
